import json
import os
import socket
import ssl
from bs4 import BeautifulSoup
from django.http import JsonResponse
from django.shortcuts import  render
from django.contrib.auth.decorators import login_required
from django.core.exceptions import ValidationError
import re
import requests
from webScan import settings
from .models import Scan, Vulnerability
from django.utils import timezone
# Create your views here.

@login_required
def profile_view(request):
     # Fetch all Vulnerability objects for the current user, along with related Scan data
    vulnerabilities = Vulnerability.objects.filter(user=request.user).select_related('scan').order_by('-scan__scan_date')

    # Prepare a list of scan results
    scan_results = []
    for index, vulnerability in enumerate(vulnerabilities, start=1):
        scan_results.append({
            'id': vulnerability.id,  # Include the vulnerability ID for viewing results
            'domain': vulnerability.domain,
            'report_name': vulnerability.report_name,
            'scan_date': vulnerability.scan.scan_date.isoformat(),  # Format for JSON
        })

    return render(request, 'home.html',{'scan_results': scan_results})

def my_view(request):
    return render(request, 'home.html', {'request':request})

#url validation
def validate_input(input_data):
    # Ensure the URL has a valid scheme (http or https)
    if not re.match(r'^(http://|https://)', input_data):
        input_data = 'http://' + input_data  # Prepend http:// if not present

    try:
        response = requests.get(input_data, timeout=5)  # Send a request to the URL
        if response.status_code == 200:
            return True, input_data  # Valid input and URL
        elif response.status_code == 404:
            return False, "Host unknown."  # 404 response
    except requests.exceptions.ConnectionError:
        # Handle DNS resolution errors (NameResolutionError)
        return False, "Host unknown. Failed to resolve domain."
    except requests.exceptions.Timeout:
        return False, "Request timed out. Please try again."
    except requests.RequestException as e:
        # Catch any other exceptions and display a generic error message
        return False, "An error occurred: " + str(e)

    return False, "Invalid domain, URL, or IP."


# scanning logic

#port scanner
def port_scan(host):
    common_ports = [20, 21, 22, 23, 25, 53, 80, 81, 110, 143, 443, 465, 587, 3306, 3389, 5432, 6379, 8080, 8443]  # List of common ports
    open_ports = []
    
    for port in common_ports:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Set a timeout of 1 second for the connection attempt
            result = s.connect_ex((host, port))  # Attempt to connect to the port
            
            if result == 0:  # If result is 0, the port is open
                open_ports.append(port)
    
    return open_ports

# ssl missing
def check_ssl_certificate(host):
    try:
        context = ssl.create_default_context()
        with socket.create_connection((host, 443)) as sock:
            sock.settimeout(5)
            ssl_sock = context.wrap_socket(sock, server_hostname=host)
            ssl_info = ssl_sock.getpeercert()
        return ssl_info
    except Exception as e:
        return None
    

#missing security headers 
def check_security_configuration(host):
    # Example check: Requesting the URL and checking security headers
    response = requests.get(f'http://{host}', timeout=5)
    missing_headers = []
    expected_headers = [ 'X-Content-Type-Options',
        'X-Frame-Options',
        'X-XSS-Protection',
        'Content-Security-Policy',
        'Strict-Transport-Security',
        'Referrer-Policy',
        'Permissions-Policy',
        'Cache-Control',
        'Access-Control-Allow-Origin',
        'X-Permitted-Cross-Domain-Policies']
    
    for header in expected_headers:
        if header not in response.headers:
            missing_headers.append(header)
    
    return missing_headers

##SQLI Scan
def sql_injection_test(url):
    try:
        response = requests.get(url, timeout=5)
        soup = BeautifulSoup(response.content, 'html.parser')
        forms = soup.find_all('form')
        sql_payloads = [
    "' OR '1'='1",
    "' OR 'a'='a",
    "' OR 'x'='x",
    "' OR 1=1--",
    "' OR '' = '",
    "' OR 1=1#",
    "' OR 1=0--",
    "' UNION SELECT NULL--",
    "' UNION SELECT username, password FROM users--",
    "' AND 1=2 UNION SELECT 1,2,3--",
    "' OR '1'='1'--",
    "' OR 1=1 LIMIT 1--",
    "' UNION SELECT 1,2,3--",
    "' OR EXISTS(SELECT * FROM users WHERE username='admin')--",
    "' OR 1=1 AND ''='",
    "' OR 1=1/*",
    "' OR '1'='1' AND '1'='1'",
    "' AND 1=2--",
    "' OR 1=1 WAITFOR DELAY '0:0:5'--",
    "' OR SLEEP(5)--",
    "' AND '1'='1'"
]


        vulnerable_forms = []

        for form in forms:
            form_action = form.get('action')
            form_method = form.get('method', 'get').lower()
            inputs = form.find_all('input')

            form_data = {}
            for input_tag in inputs:
                input_name = input_tag.get('name')
                if input_name:
                    form_data[input_name] = sql_payloads[0]  # Test with the first SQLi payload

            if form_method == 'post':
                response = requests.post(url + form_action, data=form_data)
            else:
                response = requests.get(url + form_action, params=form_data)

            if "error" in response.text.lower() or "syntax" in response.text.lower():
                vulnerable_forms.append(form_action)

        return vulnerable_forms

    except Exception as e:
        return None
    
    
#XSS Scan
# Perform XSS test
def xss_test(url):
    try:
        response = requests.get(url, timeout=5)
        soup = BeautifulSoup(response.content, 'html.parser')
        forms = soup.find_all('form')
        xss_payloads = [
    "<script>alert(1)</script>",
    "<img src=x onerror=alert(1)>",
    "<svg/onload=alert(1)>",
    "<iframe/src='javascript:alert(1)'>",
    "<body onload=alert(1)>",
    "<a href='javascript:alert(1)'>click me</a>",
    "<script>document.write('<img src=x onerror=alert(1)>');</script>",
    "<div style='background:url(javascript:alert(1))'>test</div>",
    "<input type='text' value='x' onfocus='alert(1)'>",
    "<link rel='stylesheet' href='javascript:alert(1)'>",
    "<style>@import'javascript:alert(1)';</style>",
    "<object data='javascript:alert(1)'></object>",
    "<meta http-equiv='refresh' content='0;url=javascript:alert(1)'>",
    "<script src='javascript:alert(1)'></script>",
    "<canvas onmouseover='alert(1)'></canvas>",
    "<details open ontoggle='alert(1)'><summary>Click me</summary></details>"
]


        vulnerable_forms = []

        for form in forms:
            form_action = form.get('action')
            form_method = form.get('method', 'get').lower()
            inputs = form.find_all('input')

            for payload in xss_payloads:
                form_data = {}
                for input_tag in inputs:
                    input_name = input_tag.get('name')
                    if input_name:
                        form_data[input_name] = payload  # Inject XSS payload into the form fields

                if form_method == 'post':
                    response = requests.post(url + form_action, data=form_data)
                else:
                    response = requests.get(url + form_action, params=form_data)

                if payload in response.text:  # Check if payload is reflected in the response
                    vulnerable_forms.append(form_action)
                    break  # Stop testing this form after finding it vulnerable

        return vulnerable_forms

    except Exception as e:
        return None

REPORTS_DIR = os.path.join(settings.MEDIA_ROOT, 'reports')
if not os.path.exists(REPORTS_DIR):
    os.makedirs(REPORTS_DIR)
    
def scan_view(request):
    if 'url' in request.GET:
        input_data = request.GET.get('url')
        is_valid, message = validate_input(input_data)  
        
        if is_valid:
            host = input_data.replace('http://', '').replace('https://', '').split('/')[0]
            
            open_ports = port_scan(host)
            
            ssl_info = check_ssl_certificate(host)
            
            security_issues = check_security_configuration(input_data)
            
            sqli_vulnerabilities = sql_injection_test(input_data)
            
            xss_vulnerabilities = xss_test(input_data)

            #save to database
            if request.user.is_authenticated:
           
                scan = Scan.objects.create(
                    domain=host,
                    scan_date=timezone.now(),
                    user_id=request.user.id
                )
                #create a report of the file
                report_file_name = f"reports_{host}.json"
                report_file_path = os.path.join(REPORTS_DIR, report_file_name)
                
                scan_data = {
                    'host': host,
                    # 'scan_date': timezone.now().isoformat(),
                    'open_ports': open_ports,
                    'ssl_info': ssl_info,
                    'security_issues': security_issues,
                    'sqli_vulnerabilities': sqli_vulnerabilities,
                    'xss_vulnerabilities': xss_vulnerabilities,
                }
                
                with open(report_file_path, 'w') as report_file:
                    json.dump(scan_data, report_file)
                
                
                vulnerability = Vulnerability.objects.create(
                    domain=host,
                    report_name=report_file_name, 
                    user_id=request.user.id,
                    scan=scan
                )
             
            return render(request, 'result.html', {
                'open_ports': open_ports,
                'ssl_info': ssl_info,
                'security_issues': security_issues,
                'sqli_vulnerabilities': sqli_vulnerabilities
            })
        else:
            return render(request, 'result.html', {'error': message})
    
    return render(request, 'home.html')

@login_required
def history_view(request):
    if request.user.is_authenticated:
        vulnerabilities = Vulnerability.objects.filter(user=request.user).select_related('scan').order_by('-scan__scan_date')

        scan_results = []
        for vulnerability in vulnerabilities:
            scan_results.append({
                'scan_id': vulnerability.scan_id,  # Include the vulnerability ID for viewing results
                'domain': vulnerability.domain,
                'report_name': vulnerability.report_name,
                'scan_date': vulnerability.scan.scan_date.isoformat(),  # Format for JSON
            })
        
        return JsonResponse(scan_results, safe=False)

    return JsonResponse([], safe=False)  # Return an empty list if the user is not authenticated


#view scan history
def view_scan_report(request, report_name):
    report_file_path = os.path.join(REPORTS_DIR, report_name)
    
    if os.path.exists(report_file_path):
        with open(report_file_path, 'r') as report_file:
            scan_data = json.load(report_file)

        # Render the result.html page with the report data
        return render(request, 'result.html', {
            'open_ports': scan_data.get('open_ports', []),
            'ssl_info': scan_data.get('ssl_info'),
            'security_issues': scan_data.get('security_issues', []),
            'sqli_vulnerabilities': scan_data.get('sqli_vulnerabilities', []),
            'xss_vulnerabilities': scan_data.get('xss_vulnerabilities', []),
        })
    else:
        # If the report doesn't exist, display an error
        return render(request, 'result.html', {'error': 'Report not found.'})

def result_view(request):
    return render(request,'result.html')

